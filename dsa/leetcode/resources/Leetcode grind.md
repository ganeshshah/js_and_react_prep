# Most asked coding patterns 
- two pointers
- sliding window 
- quick select and heap(min/max)
- monotonic( stack /queue)
- dfs (recursive /iterative)
- bfs (recursive /iterative)
- backtracking (take /not take)
- dp (recursion with memorization)


### binary tree problems(use dfs,bfs and recursively)-
- tree includes a value
- treeSum
- tree min value
- max root to leaf sum

### dynamic programming problems-
- Fibonacci
- minimum coins
- coins how many coins
- maze problem


[pareto problem set.pdf](https://github.com/iamsuryasonar/js_react_and_dsa_preparation/blob/main/problem_set.pdf)

[top 20 coding patterns.pdf](https://github.com/iamsuryasonar/js_react_and_dsa_preparation/blob/main/top_20_coding_patterns.pdf)

[coding patterns design guru.pdf](https://github.com/iamsuryasonar/js_react_and_dsa_preparation/blob/main/coding_patterns_design_guru.pdf)

# Websites 

[Leetcode patterns](https://seanprashad.com/leetcode-patterns/)


[Leetcode problems sorted by patterns](https://leetcode.com/discuss/post/448285/list-of-questions-sorted-by-common-patte-936d/)


[15 leetcode patterns by algomonster](https://blog.algomaster.io/p/15-leetcode-patterns)


[Must do coding questions](https://github.com/de-cryptor/Must-Do-Coding-Questions)


[Neetcode dsa sheet](https://neetcode.io/practice)


[Take you forward (striver) youtube channel](https://www.youtube.com/@takeUforward/playlists)



# Behavioural 
[toughest interview questions.pdf](https://github.com/iamsuryasonar/js_react_and_dsa_preparation/blob/main/toughest_interview_questions.pdf)


# Patterns by Data structure 
- Searching — Modified binary search
- Sorting — Merge sort, quick sort, heap sort
- Arrays — Two/Three-pointer, Sliding window, kadane’s algorithm, merge sort/intervals logic, etc
- Strings — Substrings, subsequences, pattern matching, lexicographic ordering, etc
- Binary trees & Binary search trees — Traversals like Inorder, preorder, postorder, and morris traversal (both iterative & recursive)
- Graphs — Depth-first search (DFS), breadth-first search (BFS), topological sort, cycle detection, minimum spanning tree (MST) — Prims & Kruskals, Dijkstra, Bellman-Ford, Floyd Warshall, disjoint set union (union)
- Divide & Conquer
- Dynamic programming — Memoization, tabulation



# Top 10 by topic - Most Asked DSA Questions

## Array Manipulation:
1. Find the maximum subarray sum.
2. Find the missing number in an array of integers.
3. Find the maximum product subarray.
4. Rotate an array to the right by k steps.
5. Merge two sorted arrays into a single sorted array.
6. Find the peak element in an array.
7. Implement the "next permutation" algorithm.
8. Find the longest increasing subsequence.
9. Find the maximum length of subarray with contiguous elements.
10. Determine if there are any two numbers in an array whose sum equals a given target.

## String Manipulation:
1. Reverse a string.
2. Check if a string is a palindrome.
3. Find the longest substring without repeating characters.
4. Implement strstr (substring search).
5. Count and Say problem.
6. Longest common prefix among an array of strings.
7. Implement regular expression matching.
8. Longest palindromic substring.
9. Group words with the same pattern in a string array.
10. Implement strstr (substring search).

## Linked Lists:
1. Implement basic operations (insertion, deletion, traversal).
2. Find the middle of a linked list.
3. Detect a cycle in a linked list.
4. Reverse a linked list in groups of k.
5. Merge two sorted linked lists.
6. Flatten a multilevel linked list.
7. Implement LRU Cache using a linked list.
8. Reorder linked list.
9. Reverse nodes in k-group.
10. Clone a linked list with random pointers.

## Stacks and Queues:
1. Implement a stack using arrays or linked lists.
2. Implement a queue using stacks.
3. Evaluate postfix expressions using a stack.
4. Implement a min stack with O(1) getMin() operation.
5. Implement a circular queue.
6. Validate parentheses in a string using a stack.
7. Implement a stack using queues.
8. Implement a queue using stacks.
9. Design a data structure that supports push, pop, top, and retrieving the minimum element in constant time.
10. Implement a circular queue using arrays.

## Binary Trees:
1. Implement basic operations (insertion, deletion, traversal).
2. Find the height or depth of a binary tree.
3. Check if a binary tree is balanced.
4. Check if two binary trees are identical.
5. Find the lowest common ancestor (LCA) of two nodes in a binary tree.
6. Serialize and deserialize a binary tree.
7. Find the maximum width of a binary tree.
8. Find the vertical sum of a binary tree.
9. Find the boundary traversal of a binary tree.
10. Convert a binary tree to its mirror tree.

## Binary Search and Sorting:
1. Implement binary search in a sorted array.
2. Implement sorting algorithms (e.g., bubble sort, insertion sort, merge sort).
3. Find the median of two sorted arrays.
4. Search in a 2D matrix.
5. Find the peak element in a 2D array.
6. Implement heap sort.
7. Find Kth largest element in an array.
8. Find K closest elements in a sorted array.
9. Merge intervals.
10. Implement the "next permutation" algorithm.

## Hashing:
1. Implement a hash table.
2. Find duplicates in an array using hashing.
3. Implement LRU cache.
4. Group anagrams from an array of strings.
5. Find all pairs in an array with a given sum.
6. Subarray with zero sum.
7. Implement a hash map with constant-time operations.
8. Find the longest substring without repeating characters.
9. Check if two strings are isomorphic.
10. Implement a Trie data structure.

## Graphs:
1. Implement basic graph traversal algorithms (BFS, DFS).
2. Find the shortest path in a weighted graph (Dijkstra's algorithm).
3. Find the number of islands (connected components) in a 2D matrix.
4. Clone an undirected graph.
5. Check if a graph is bipartite.
6. Find the shortest path in a directed acyclic graph (DAG).
7. Detect cycle in an undirected graph.
8. Find the bridges in a graph.
9. Check if a graph is a tree.
10. Find the articulation points in a graph.

## Dynamic Programming:
1. Fibonacci sequence.
2. Longest increasing subsequence.
3. 0/1 Knapsack problem.
4. Minimum number of jumps to reach the end.
5. Longest increasing subsequence of consecutive elements.
6. Partition equal subset sum.
7. Regular expression matching.
8. Maximum profit by buying and selling stocks.
9. Minimum number of coins for change.
10. Unique paths in a grid.

## Recursion:
1. Implement factorial of a number.
2. Implement Tower of Hanoi.
3. Generate all permutations of a string.
4. Generate all valid parentheses combinations.
5. Generate all possible expressions that evaluate to a target value.
6. Generate all subsets of a set.
7. Implement a Sudoku solver.
8. Generate all permutations of a string with duplicate characters.
9. Generate all combinations of a set of numbers.
10. Find all paths from root to leaf nodes in a binary tree.


# Patterns recognition 

If input array is sorted then
- Binary search
- Two pointers

If asked for all permutations/subsets then
- Backtracking

If given a tree then
- DFS
- BFS

If given a graph then
- DFS
- BFS

If given a linked list then
- Two pointers

If recursion is banned then
- Stack

If must solve in-place then
- Swap corresponding values
- Store one or more different values in the same pointer

If asked for maximum/minimum subarray/subset/options then
- Dynamic programming

If asked for top/least K items then
- Heap
- QuickSelect

If asked for common strings then
- Map
- Trie

Else
- Map/Set for O(1) time & O(n) space
- Sort input for O(nlogn) time and O(1) space

# Patterns (Used for)

### Two pointers
Pointers moving towards each other - Good for sorted arrays ot finding a pair of elements with specific sum
Pointers moving is same direction - Useful when we need to track a range that satisfies condition
Fast and slow pointers - Cycle detection or finding middle of a linked list
Used for- 
- Pair search
- Subarray search
- Sequence search

### Sliding Window
Used for- 
- Finding subarrays
- Finding sublists
- FInding substrings
Questions
- Max sum subarrays
- Longest substring without repeating characters
- Min size subarray with given sum

### DFS
Recursion of stack involved
Used for- 
- Graph traversal
- Finding connected components
- Depth related properties

### Dynamic programming
Used for- 
- Longest common subsequence
- Shortest path
- Maximisation or minimisation
Questions
- Climbing stairs
- House Robber
- Coin Change

# Some more patterns 
- preffix and suffix array
- Trapping rain water
- product-of-array-except-self
- Devide and conquer
- K-way merge
- Topology sort (directed graph)