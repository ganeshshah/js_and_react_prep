# Most Asked DSA Questions

## Array Manipulation:
1. Find the maximum subarray sum.
2. Find the missing number in an array of integers.
3. Find the maximum product subarray.
4. Rotate an array to the right by k steps.
5. Merge two sorted arrays into a single sorted array.
6. Find the peak element in an array.
7. Implement the "next permutation" algorithm.
8. Find the longest increasing subsequence.
9. Find the maximum length of subarray with contiguous elements.
10. Determine if there are any two numbers in an array whose sum equals a given target.

## String Manipulation:
1. Reverse a string.
2. Check if a string is a palindrome.
3. Find the longest substring without repeating characters.
4. Implement strstr (substring search).
5. Count and Say problem.
6. Longest common prefix among an array of strings.
7. Implement regular expression matching.
8. Longest palindromic substring.
9. Group words with the same pattern in a string array.
10. Implement strstr (substring search).

## Linked Lists:
1. Implement basic operations (insertion, deletion, traversal).
2. Find the middle of a linked list.
3. Detect a cycle in a linked list.
4. Reverse a linked list in groups of k.
5. Merge two sorted linked lists.
6. Flatten a multilevel linked list.
7. Implement LRU Cache using a linked list.
8. Reorder linked list.
9. Reverse nodes in k-group.
10. Clone a linked list with random pointers.

## Stacks and Queues:
1. Implement a stack using arrays or linked lists.
2. Implement a queue using stacks.
3. Evaluate postfix expressions using a stack.
4. Implement a min stack with O(1) getMin() operation.
5. Implement a circular queue.
6. Validate parentheses in a string using a stack.
7. Implement a stack using queues.
8. Implement a queue using stacks.
9. Design a data structure that supports push, pop, top, and retrieving the minimum element in constant time.
10. Implement a circular queue using arrays.

## Binary Trees:
1. Implement basic operations (insertion, deletion, traversal).
2. Find the height or depth of a binary tree.
3. Check if a binary tree is balanced.
4. Check if two binary trees are identical.
5. Find the lowest common ancestor (LCA) of two nodes in a binary tree.
6. Serialize and deserialize a binary tree.
7. Find the maximum width of a binary tree.
8. Find the vertical sum of a binary tree.
9. Find the boundary traversal of a binary tree.
10. Convert a binary tree to its mirror tree.

## Binary Search and Sorting:
1. Implement binary search in a sorted array.
2. Implement sorting algorithms (e.g., bubble sort, insertion sort, merge sort).
3. Find the median of two sorted arrays.
4. Search in a 2D matrix.
5. Find the peak element in a 2D array.
6. Implement heap sort.
7. Find Kth largest element in an array.
8. Find K closest elements in a sorted array.
9. Merge intervals.
10. Implement the "next permutation" algorithm.

## Hashing:
1. Implement a hash table.
2. Find duplicates in an array using hashing.
3. Implement LRU cache.
4. Group anagrams from an array of strings.
5. Find all pairs in an array with a given sum.
6. Subarray with zero sum.
7. Implement a hash map with constant-time operations.
8. Find the longest substring without repeating characters.
9. Check if two strings are isomorphic.
10. Implement a Trie data structure.

## Graphs:
1. Implement basic graph traversal algorithms (BFS, DFS).
2. Find the shortest path in a weighted graph (Dijkstra's algorithm).
3. Find the number of islands (connected components) in a 2D matrix.
4. Clone an undirected graph.
5. Check if a graph is bipartite.
6. Find the shortest path in a directed acyclic graph (DAG).
7. Detect cycle in an undirected graph.
8. Find the bridges in a graph.
9. Check if a graph is a tree.
10. Find the articulation points in a graph.

## Dynamic Programming:
1. Fibonacci sequence.
2. Longest increasing subsequence.
3. 0/1 Knapsack problem.
4. Minimum number of jumps to reach the end.
5. Longest increasing subsequence of consecutive elements.
6. Partition equal subset sum.
7. Regular expression matching.
8. Maximum profit by buying and selling stocks.
9. Minimum number of coins for change.
10. Unique paths in a grid.

## Recursion:
1. Implement factorial of a number.
2. Implement Tower of Hanoi.
3. Generate all permutations of a string.
4. Generate all valid parentheses combinations.
5. Generate all possible expressions that evaluate to a target value.
6. Generate all subsets of a set.
7. Implement a Sudoku solver.
8. Generate all permutations of a string with duplicate characters.
9. Generate all combinations of a set of numbers.
10. Find all paths from root to leaf nodes in a binary tree.